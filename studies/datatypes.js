/* DATATYPES
DATATYPES IN JAVASCRIPT REFERS TO THE TYPE OF DATA THAT IS STORED IN A VARAIBLE.
ITS IMPORTANT TO REMEBER THE SYNTAX THAT IS USED WITH EACH TO AVOID ERRORS. 
*/


/* 1. NUMBER
* THE DATATYPE NUMBER SIGNIFIES THAT THE VALUE IS A MATHMATICAL NUMBER. 
THIS DATATYPE DOES NOT NEED TO BE ASSIGNED WITH 
*  SINGLE OR DOUBLE QUOTATION MARKS. FOR INSTANCE:
*/
  var myNum = 1;

/* 2. STRING
* THE DATATYPE STRING SIGNIFIES THAT THE VALUE IS A STRING OF CHARACTERS. 
THIS DATATYPE MUST BE IN SINGLE OR DOUBLE 
* QOUTATION MARKS. FOR INSTANCE:
*/

 var myString = 'string';

/* 3. BOOLEAN
* THE DATATYPE BOOLEAN SIGNIFIES THAT THE VALUE WILL EITHER BE TRUE OR FALSE.
THIS DATATYPE DOES NOT NEED TO IN 
* SINGLE OR DOUBLE QUOTATIONS. FOR INSTANCE:
*/

  var myBool = true;

/* 4. ARRAY 
* THE DATATYPE ARRAY SIGNIFIES THAT THE VALUE WILL BE AN COLLECTION.
THIS COLLECTION CAN BE A MIX OF DATAYPES. YOU CAN ACCESS VARIABLES INSIDE OF 
AN ARRAY USING BRACKET NOTATION. ARRAYS CAN HOUSE AN ENDLESS AMOUNT OF 
PROPERTIES. 
* ARRAYS MUST BE LISTED WITH BRACKETS. FOR INSTANCE:
*/
 
 var myArray = ['dog', true, 1];

/* 5. OBJECT
* THE DATATYPE OBJECT SIGNIFIES A COMPLEX DATATYPE THAT STORES IT VALUES IN
* KEY/VALUE PAIRS. UNLIKE AN ARRAY - OBJECTS VALUES ARE NOT STORED WITH INDEX 
* VALUES. THESE VALUES MAY BE ACCESSED WITH BRACKET & DOT NOTATION.  LIKE 
* ARRAYS, OBJECTS CAN HOLD AN ENDLESS AMOUNT OF DATA. 
*/

 var myObject = {
    name: 'Samantha',
    dog: 'Basil',
    city: 'New Orleans'
};
/* 5. FUNCTION
* A FUNCTION SIGNIFIES A DATATYPE THAT CAN SERVE A LARGE AMOUNT OF PROCEDURES.
A FUNCTION CONSISTS OF A FUNCTION 
DECLARATIONS AND A FUNCTION BODY. AFTER THE FUNCTION BODY IS COMPLETED, YOU CAN
CALL A FUNCTION SIMPLY BE CALLING ITS
NAME ALONG WITH THE ARGUMENTS YOU'D LIKE TO PASS THROUGH IT. 
*/

function myFunction (num1, num2) { // num1 + num2 are parameters
    console.log(num1+num2);//code body;
    //return statment optional
}
myFunction(2, 5); // prints to console => 7; 


/* 6. UNDEFINED
* UNDEFINED AS A DATATYPE SIGNIFIES THAT THE VARIABLE YOU ARE SEARCHING HAS BEEN 
* DECLARED IN YOUR CODE - BUT NOT DEFINED. 
*/

function undef(param){
  return; //code block that doesnt contain a return statement
}

undef(); // returns undefined

 /* 7. NULL

NULL IS AN OBJECT VALUE THAT MEANS NADA! ZILCH! IF YOU'RE TIRED OF SEEING THAT 
PESKY UNDEFINED, NULL IS A GOOD WAY TO 
SHOW THAT THAT EMPTINESS IS INTENTIONAL. FOR INSTANCE:
*/

function howMuchMoneyDoIHave(){
    return null; 
}

howMuchMoneyDoIHave(); // prints to console => null; 

/*8. NaN

NaN STANDS FOR NOT A NUMBER. IT CAN BE USED LIKE THIS:

*/

function whatIsNumber(i) {
  if (isNaN(i)) {
    console.log(NaN);
  }
  console.log(i);
}



whatIsNumber(13); // prints to console => 13
whatIsNumber('dog'); // prints to console => NaN

/* 9. INFINITY 

INFINITY IS A POSITIVE INTERGER VALUE. MEANING INFINITY. IT CAN BE WRITTEN LIKE
THIS: 

*/
var exampleNum = 0; 
var largestNum = Infinity;  

function doNotExceed(num){
    if(num > largestNum){
        return null; 
    }
}


/* 9. NEGATIVE INFINITY 

NEGATIVE INFINITY IS A NEGAVTIVE INTERGER VALUE. MEANING NEGATIVE INFINITY.
IT CAN BE WRITTEN LIKE THIS:

*/

var negativeNum = -Infinity;

function doNotExceed(num){
    if(num < negativeNum){
        return null; 
    }
}



/* 10. WHAT'S THE DIFFERENCE BETWEEN PRIMITIVE/SIMPLE AND COMPLEX DATA TYPES?

SIMPLE/PRIMITIVE DATA TYPES ARE IMMUTABLE VALUES THAT DO NOT HOLD OR COLLECT
OTHER VALUES. SOME EXAMPLES OF SIMPLE 
DATA TYPES INCLUDE: 
-STRINGS
-BOOLEANS
-NUMBERS

COMPLEX DATA TYPES ARE MUTABLE AND CAN BE CHANGED AT ANY POINT. THEY CAN GROW
INDEFINETLY AND BE ALTERED AT ANY TIME. 
SOME COMPLEX DATA TYPES INCLUDE:
-OBJECTS
-ARRAYS

*/


/* 11. COPY BY VALUE & COPY BY REFERENCE: 

COPY BY VALUE REFERS TO HOW SIMPLE DATA TYPES ARE REFERED TO IN FUNCITIONS. 
YOU CAN THINK ABOUT IT LIKE COPY AND PASTE.
IF YOU'RE IN A FUNCTION AND CALL THE VARIABLE myName, IT WILL SIMPLY FIND THE
VARIABLE AND PASTE IT WHERE ITS CALLED

COPY BY REFERENCE REFERS TO HOW COMPLEX DATA TYPES ARE REFERENCED TO IN 
FUNCTIONS. COPY BY REFERENC SIMPLY MEANS 
INSTEAD OF A COPY AND PASTE STYLE, JAVASCRIPT WILL RETRIEVE THE COMPLEX DATATYPE
WITHIN REFERENC OF ITS LATEST FORM.
*/

// copy by value looks like this:


let person1 = 'Sam';
let person2 = person1;
person1 = 'John';

console.log(person1); // John
console.log(person2); // Michael


// copy by reference looks like this:

 myObject = {
    1 : 'dog',
    2 : 'cat',
    3 : 'chicken',
    4 : 'fish'
};

console.log(Object.values(myObject));// prints to console => [ 'dog', 'cat', 'chicken', 'fish' ]