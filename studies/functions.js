/* FUNCTIONS 

FUNCTIONS ARE VERY USEFUL WHEN CODING. THEY ALLOW YOU TO WRITE BLOCKS OF CODE 
THAT ARE REUSABLE AND WILL ULTIMATELY SAVE YOU A LOT OF TIME. SINCE THEY ARE 
REUSABLE, FUNCTIONS CAN HELP YOU CREATE CODE THAT CAN SERVE MULTIPLE PURPOSES. 

*/

/*  1. IN ORDER TO USE FUNCTIONS FIRST WE MUST DECLARE THEM AND THEN WE MUST
CALL THEM. FOR INSTANCE:
*/ 

  function myFunc(parameter1, parameter2){
      //code block here 
      //RETURN STATEMENT OPTIONAL 
  }
   
 //   myFunc(argument1, argument2);
 
/*2. IN THE EXAMPLE ABOVE WE SEE WHAT ARE CALLED PARAMETER AND ARGUMENTS.
THE PARAMETERS LIVE IN THE PARENTHESIS
ALONGSIDE THE FUNCTION DEFINTION AND TELL THE FUNCTION 'HEY THIS IS WHAT WE
WILL BE PASSING THROUGH'.

THE ARGUMENTS ARE WHAT YOU PASS THROUGH THE FUNCTION AT THE TIME OF CALLING 
IT. THAT WILL LOOK LIKE THIS. 
*/

function letsMultiply(num1, num2) {
    return num1 * num2; 
}

letsMultiply(3,4); // returns 12; 

// 3. THE SYNTAX FOR A NAMED FUNCTION LOOKS LIKE THIS: 

function functionName(values) {
    //code block here
}


/* WE CAN ASSIGN A FUNCTION TO A VARIABLE JUST AS SIMPLY AS WE ASSIGN 
ANYTHING TO A VARIABLE. LETS TAKE OUR
EXAMPLE FUNCTION FROM ABOVE AND ASSIGN IT TO THE VARIABLE myExample. */

// var myExample = function letsMultiply()

/* NOTICE AT THIS POINT YOU DO NOT NEED TO SPECIFY AGAIN THE PARAMATERS OR 
CODE BLOCK. 
*/

/* 5. NOT ALL FUNCTIONS ARE CREATED EQUAL. NOT ALL TAKE INPUTS & NOT ALL
RETURN A SINGLE VALUE.
FOR INSTANCE IF YOU WANTED TO CALL A FUNCTION WITH NO PARAMETERS OR ARGUMENTS 
YOU WOULD DO JUST THAT */

function callMe(){
    console.log('hi');
}

callMe();//prints to console => hi 


/* 6. SCOPE: 
FUNCTION SCOPE IS THE SCOPE SPECIFIC TO THE FUNCTION. IF YOU ARE USING GLOBAL
VARIABLES YOU CAN CALL THEM IN YOUR 
FUNCTION LIKE YOU WOULD ANYWHERE ELSE, HOWEVER IF YOU DECLARE A VARIABLE INSIDE
YOUR FUNCTION USING LET OR CONST, 
THOSE WILL NOT BE ABLE TO BE CALLED ANYWHERE OUTSIDE YOUR FUNCTION. 
*/

//TO BETTER UNDERSTAND - LETS DEMONSTRATE WITH VAR 

var myExample = 10

function myExampleFunction(){
  myExample = 13
}
console.log(myExample)//prints to console => 10

//ALTHOUGH myExample HAS BEEN REASSIGNED TO 13 INSIDE OF THE FUNCTION(WHICH IS 
//HOISTED ABOVE OUR VARIABLE) - SINCE THE REASSIGNMENT OCCURS IN OUR BLOCK SCOPE
//WE CANNOT ACCESS THE NEW VALUE - ONLY THE GLOBAL VALUE


//NOW WHAT ABOUT LET AND CONST?

console.log(a);
let a = 3;
// or 
const anotherA = 3; 

console.log(a);// prints to console => ref error a is not defined
//console.log(anotherA); // prints to console => ref error anotherA is not
//defined


//HOW IS THIS DIFFERENT FROM VAR? WHEN VAR IS HOISTED IT IS INITIALIZED 
//MEANING - IF THE EXAMPLE ABOVE INCLUDED VAR INSTEAD OF LET/CONST OUR CONSOLE
//WOULD READ UNDEFINED. 


/*7. CLOSURE:

WHILE CLOSURE EXISTS AROUND EVERY FUNCTION WE CREATE, IT STILL MIGHT NOT
BE THE EASIEST TO UNDERSTAND. THE WAY I LIKE 
TO REMEMBER CLOSURE IS LIKE A RECIEPT. THIS WILL TELL US A LITTLE BIT
ABOUT THE FUNCTION AND HOW IT WAS CREATED 
AND THE RULES IT FOLLOWS. AND EVEN IF WE ALTER THE FUNCTION LATER, THE 
PAST CLOSURE DOESN NOT NECESSARILY GO AWAY. THIS 
INFORMATION WILL BE STORED IN MEMORY AND CAN BE REFERENCED LATER.*/

var example = 1;

function myClosure(){
    function returnExample(){
        console.log(example)
    }
    return returnExample();
}

myClosure(); //prints to console 1 

